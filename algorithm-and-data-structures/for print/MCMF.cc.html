<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/Programming/competition/ACM/Algorithm/MCMF.cc.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v9">
<meta name="syntax" content="cpp">
<meta name="settings" content="number_lines,use_css,pre_wrap,expand_tabs">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
.lnr { color: #a52a2a; }
.cBinaryOperator { color: #3564b4; }
.Special { color: #6a5acd; }
.cPointerOperator { color: #3564b4; }
.cLogicalOperator { color: #3564b4; }
.cMathOperator { color: #3564b4; }
.cFunction { color: #25aadc; }
.Type { color: #2e8b57; font-weight: bold; }
.Statement { color: #a52a2a; font-weight: bold; }
.Constant { color: #ff00ff; }
.PreProc { color: #a020f0; }
.Comment { color: #0000ff; }
-->
</style>
</head>
<body>
    <h2>MCMF</h2>
<pre>
<span class="lnr">  1 </span><span class="Comment">/*</span>
<span class="lnr">  2 </span><span class="Comment"> *  SRC: POJ 2516</span>
<span class="lnr">  3 </span><span class="Comment"> * PROB: Minimum Cost</span>
<span class="lnr">  4 </span><span class="Comment"> * ALGO: MCMF</span>
<span class="lnr">  5 </span><span class="Comment"> * DATE: Jun 3, 2011 </span>
<span class="lnr">  6 </span><span class="Comment"> * COMP: g++</span>
<span class="lnr">  7 </span><span class="Comment"> *</span>
<span class="lnr">  8 </span><span class="Comment"> * Created by Leewings Ac</span>
<span class="lnr">  9 </span><span class="Comment"> </span><span class="Comment">*/</span>
<span class="lnr"> 10 </span>
<span class="lnr"> 11 </span><span class="PreProc">#include </span><span class="Constant">&lt;cstdio&gt;</span>
<span class="lnr"> 12 </span><span class="PreProc">#include </span><span class="Constant">&lt;cstring&gt;</span>
<span class="lnr"> 13 </span><span class="PreProc">#include </span><span class="Constant">&lt;vector&gt;</span>
<span class="lnr"> 14 </span><span class="PreProc">#include </span><span class="Constant">&lt;queue&gt;</span>
<span class="lnr"> 15 </span>
<span class="lnr"> 16 </span><span class="Statement">using</span> std::vector;
<span class="lnr"> 17 </span><span class="Statement">using</span> std::queue;
<span class="lnr"> 18 </span>
<span class="lnr"> 19 </span><span class="Type">struct</span> Edge {
<span class="lnr"> 20 </span>    <span class="Type">int</span> v, p;
<span class="lnr"> 21 </span>    <span class="Type">int</span> c, f; <span class="Comment">// capa, flow</span>
<span class="lnr"> 22 </span>    <span class="Type">int</span> cpf; <span class="Comment">// cost per flow</span>
<span class="lnr"> 23 </span>
<span class="lnr"> 24 </span>    <span class="cFunction">Edge</span>(<span class="Type">int</span> vv, <span class="Type">int</span> pp, <span class="Type">int</span> cc, <span class="Type">int</span> ff, <span class="Type">int</span> cost)
<span class="lnr"> 25 </span>        : <span class="cFunction">v</span>(vv), <span class="cFunction">p</span>(pp), <span class="cFunction">c</span>(cc), <span class="cFunction">f</span>(ff), <span class="cFunction">cpf</span>(cost)
<span class="lnr"> 26 </span>    { }
<span class="lnr"> 27 </span>};
<span class="lnr"> 28 </span>
<span class="lnr"> 29 </span><span class="Type">const</span> <span class="Type">int</span> INF <span class="cMathOperator">=</span> <span class="Constant">0x7fffffff</span>;
<span class="lnr"> 30 </span><span class="Type">const</span> <span class="Type">int</span> MAXN <span class="cMathOperator">=</span> <span class="Constant">200</span>;
<span class="lnr"> 31 </span><span class="Type">const</span> <span class="Type">int</span> src <span class="cMathOperator">=</span> <span class="Constant">0</span>, dest <span class="cMathOperator">=</span> MAXN;
<span class="lnr"> 32 </span>
<span class="lnr"> 33 </span>vector<span class="cLogicalOperator">&lt;</span>Edge<span class="cLogicalOperator">&gt;</span> edge[MAXN <span class="cMathOperator">+</span> <span class="Constant">1</span>];
<span class="lnr"> 34 </span>
<span class="lnr"> 35 </span><span class="Type">struct</span> Route {
<span class="lnr"> 36 </span>    <span class="Type">int</span> u, v, p;
<span class="lnr"> 37 </span>
<span class="lnr"> 38 </span>    <span class="cFunction">Route</span>(<span class="Type">int</span> uu <span class="cMathOperator">=</span> <span class="Constant">0</span>, <span class="Type">int</span> vv <span class="cMathOperator">=</span> <span class="Constant">0</span>, <span class="Type">int</span> pp <span class="cMathOperator">=</span> <span class="Constant">0</span>)
<span class="lnr"> 39 </span>        : <span class="cFunction">u</span>(uu), <span class="cFunction">v</span>(vv), <span class="cFunction">p</span>(pp)
<span class="lnr"> 40 </span>    { }
<span class="lnr"> 41 </span>} aRoute[MAXN <span class="cMathOperator">+</span> <span class="Constant">1</span>];
<span class="lnr"> 42 </span>
<span class="lnr"> 43 </span><span class="Type">bool</span> vis[MAXN <span class="cMathOperator">+</span> <span class="Constant">1</span>];
<span class="lnr"> 44 </span><span class="Type">int</span> lowest[MAXN <span class="cMathOperator">+</span> <span class="Constant">1</span>];
<span class="lnr"> 45 </span>
<span class="lnr"> 46 </span><span class="Type">inline</span> <span class="Type">int</span> <span class="cFunction">min</span>(<span class="Type">int</span> a, <span class="Type">int</span> b)
<span class="lnr"> 47 </span>{
<span class="lnr"> 48 </span>    <span class="Statement">return</span> a <span class="cLogicalOperator">&lt;</span> b ? a : b;
<span class="lnr"> 49 </span>}
<span class="lnr"> 50 </span>
<span class="lnr"> 51 </span><span class="Type">bool</span> <span class="cFunction">spfa</span>()
<span class="lnr"> 52 </span>{
<span class="lnr"> 53 </span>    <span class="cFunction">memset</span>(vis, <span class="Constant">false</span>, <span class="Statement">sizeof</span>(vis));
<span class="lnr"> 54 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">0</span>; i <span class="cLogicalOperator">&lt;=</span> MAXN; i<span class="cMathOperator">++</span>) lowest[i] <span class="cMathOperator">=</span> INF;
<span class="lnr"> 55 </span>
<span class="lnr"> 56 </span>    queue<span class="cLogicalOperator">&lt;</span><span class="Type">int</span><span class="cLogicalOperator">&gt;</span> Q;
<span class="lnr"> 57 </span>    Q<span class="cPointerOperator">.</span><span class="cFunction">push</span>(src);
<span class="lnr"> 58 </span>    vis[src] <span class="cMathOperator">=</span> <span class="Constant">true</span>;
<span class="lnr"> 59 </span>    lowest[src] <span class="cMathOperator">=</span> <span class="Constant">0</span>;
<span class="lnr"> 60 </span>    aRoute[src] <span class="cMathOperator">=</span> <span class="cFunction">Route</span>(<span class="cMathOperator">-</span><span class="Constant">1</span>, <span class="Constant">0</span>, <span class="cMathOperator">-</span><span class="Constant">1</span>);
<span class="lnr"> 61 </span>
<span class="lnr"> 62 </span>    <span class="Statement">while</span> (<span class="cLogicalOperator">!</span>Q<span class="cPointerOperator">.</span><span class="cFunction">empty</span>()) {
<span class="lnr"> 63 </span>        <span class="Type">int</span> u <span class="cMathOperator">=</span> Q<span class="cPointerOperator">.</span><span class="cFunction">front</span>();
<span class="lnr"> 64 </span>        Q<span class="cPointerOperator">.</span><span class="cFunction">pop</span>();
<span class="lnr"> 65 </span>        vis[u] <span class="cMathOperator">=</span> <span class="Constant">false</span>;
<span class="lnr"> 66 </span>        <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">0</span>; i <span class="cLogicalOperator">&lt;</span> edge[u]<span class="cPointerOperator">.</span><span class="cFunction">size</span>(); i<span class="cMathOperator">++</span>) {
<span class="lnr"> 67 </span>            <span class="Type">int</span> v <span class="cMathOperator">=</span> edge[u][i]<span class="cPointerOperator">.</span>v;
<span class="lnr"> 68 </span>            <span class="Type">int</span> dis <span class="cMathOperator">=</span> edge[u][i]<span class="cPointerOperator">.</span>cpf;
<span class="lnr"> 69 </span>            <span class="Statement">if</span> (dis <span class="cMathOperator">+</span> lowest[u] <span class="cLogicalOperator">&lt;</span> lowest[v] <span class="cLogicalOperator">&amp;&amp;</span> edge[u][i]<span class="cPointerOperator">.</span>f <span class="cLogicalOperator">&lt;</span> edge[u][i]<span class="cPointerOperator">.</span>c) {
<span class="lnr"> 70 </span>                lowest[v] <span class="cMathOperator">=</span> dis <span class="cMathOperator">+</span> lowest[u];
<span class="lnr"> 71 </span>                aRoute[v] <span class="cMathOperator">=</span> <span class="cFunction">Route</span>(u, v, i);
<span class="lnr"> 72 </span>                <span class="Statement">if</span> (vis[v] <span class="cLogicalOperator">==</span> <span class="Constant">false</span>) {
<span class="lnr"> 73 </span>                    vis[v] <span class="cMathOperator">=</span> <span class="Constant">true</span>;
<span class="lnr"> 74 </span>                    Q<span class="cPointerOperator">.</span><span class="cFunction">push</span>(v);
<span class="lnr"> 75 </span>                }
<span class="lnr"> 76 </span>            }
<span class="lnr"> 77 </span>        }
<span class="lnr"> 78 </span>    }
<span class="lnr"> 79 </span>
<span class="lnr"> 80 </span>    <span class="Statement">return</span> lowest[dest] <span class="cLogicalOperator">&lt;</span> INF;
<span class="lnr"> 81 </span>}
<span class="lnr"> 82 </span>
<span class="lnr"> 83 </span><span class="Type">int</span> <span class="cFunction">flow</span>()
<span class="lnr"> 84 </span>{
<span class="lnr"> 85 </span>    <span class="Type">int</span> minFlow <span class="cMathOperator">=</span> INF;
<span class="lnr"> 86 </span>    Route r <span class="cMathOperator">=</span> aRoute[dest];
<span class="lnr"> 87 </span>    <span class="Statement">while</span> (r<span class="cPointerOperator">.</span>u <span class="cLogicalOperator">!=</span> <span class="cMathOperator">-</span><span class="Constant">1</span>) {
<span class="lnr"> 88 </span>        minFlow <span class="cMathOperator">=</span> <span class="cFunction">min</span>(minFlow, edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>c <span class="cMathOperator">-</span> edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>f);
<span class="lnr"> 89 </span>        r <span class="cMathOperator">=</span> aRoute[r<span class="cPointerOperator">.</span>u];
<span class="lnr"> 90 </span>    }
<span class="lnr"> 91 </span>
<span class="lnr"> 92 </span>    <span class="Type">int</span> res <span class="cMathOperator">=</span> <span class="Constant">0</span>;
<span class="lnr"> 93 </span>    r <span class="cMathOperator">=</span> aRoute[dest];
<span class="lnr"> 94 </span>    <span class="Statement">while</span> (r<span class="cPointerOperator">.</span>u <span class="cLogicalOperator">!=</span> <span class="cMathOperator">-</span><span class="Constant">1</span>) {
<span class="lnr"> 95 </span>        edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>f <span class="cMathOperator">+=</span> minFlow;
<span class="lnr"> 96 </span>        res <span class="cMathOperator">+=</span> edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>cpf;
<span class="lnr"> 97 </span>        <span class="Type">int</span> j <span class="cMathOperator">=</span> edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>p;
<span class="lnr"> 98 </span>        edge[r<span class="cPointerOperator">.</span>v][j]<span class="cPointerOperator">.</span>f <span class="cMathOperator">=</span> <span class="cMathOperator">-</span>edge[r<span class="cPointerOperator">.</span>u][r<span class="cPointerOperator">.</span>p]<span class="cPointerOperator">.</span>f;
<span class="lnr"> 99 </span>        r <span class="cMathOperator">=</span> aRoute[r<span class="cPointerOperator">.</span>u];
<span class="lnr">100 </span>    }
<span class="lnr">101 </span>    res <span class="cMathOperator">*=</span> minFlow;
<span class="lnr">102 </span>
<span class="lnr">103 </span>    <span class="Statement">return</span> res;
<span class="lnr">104 </span>}
<span class="lnr">105 </span>
<span class="lnr">106 </span><span class="Type">int</span> <span class="cFunction">mcmf</span>()
<span class="lnr">107 </span>{
<span class="lnr">108 </span>    <span class="Type">int</span> res <span class="cMathOperator">=</span> <span class="Constant">0</span>;
<span class="lnr">109 </span>    <span class="Statement">while</span> (<span class="cFunction">spfa</span>()) res <span class="cMathOperator">+=</span> <span class="cFunction">flow</span>();
<span class="lnr">110 </span>
<span class="lnr">111 </span>    <span class="Statement">return</span> res;
<span class="lnr">112 </span>}
<span class="lnr">113 </span>
<span class="lnr">114 </span><span class="Type">void</span> <span class="cFunction">addEdge</span>(<span class="Type">int</span> u, <span class="Type">int</span> v, <span class="Type">int</span> capa, <span class="Type">int</span> flow, <span class="Type">int</span> cpf)
<span class="lnr">115 </span>{
<span class="lnr">116 </span>
<span class="lnr">117 </span>    edge[u]<span class="cPointerOperator">.</span><span class="cFunction">push_back</span>(<span class="cFunction">Edge</span>(v, edge[v]<span class="cPointerOperator">.</span><span class="cFunction">size</span>(), capa, flow, cpf));
<span class="lnr">118 </span>    edge[v]<span class="cPointerOperator">.</span><span class="cFunction">push_back</span>(<span class="cFunction">Edge</span>(u, edge[u]<span class="cPointerOperator">.</span><span class="cFunction">size</span>() <span class="cMathOperator">-</span> <span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="cMathOperator">-</span>cpf));
<span class="lnr">119 </span>}
<span class="lnr">120 </span>
<span class="lnr">121 </span><span class="Type">int</span> N, M, K;
<span class="lnr">122 </span><span class="Type">int</span> orders[<span class="Constant">60</span>][<span class="Constant">60</span>], storage[<span class="Constant">60</span>][<span class="Constant">60</span>], dist[<span class="Constant">60</span>][<span class="Constant">60</span>][<span class="Constant">60</span>];
<span class="lnr">123 </span>
<span class="lnr">124 </span><span class="Type">bool</span> <span class="cFunction">init</span>()
<span class="lnr">125 </span>{
<span class="lnr">126 </span>    <span class="cFunction">scanf</span>(<span class="Constant">&quot;</span><span class="Special">%d%d%d</span><span class="Constant">&quot;</span>, <span class="cBinaryOperator">&amp;</span>N, <span class="cBinaryOperator">&amp;</span>M, <span class="cBinaryOperator">&amp;</span>K);
<span class="lnr">127 </span>    <span class="Statement">if</span> (N <span class="cLogicalOperator">==</span> <span class="Constant">0</span> <span class="cLogicalOperator">&amp;&amp;</span> M <span class="cLogicalOperator">==</span> <span class="Constant">0</span> <span class="cLogicalOperator">&amp;&amp;</span> K <span class="cLogicalOperator">==</span> <span class="Constant">0</span>) <span class="Statement">return</span> <span class="Constant">false</span>;
<span class="lnr">128 </span>
<span class="lnr">129 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> N; i<span class="cMathOperator">++</span>)
<span class="lnr">130 </span>        <span class="Statement">for</span> (<span class="Type">int</span> j <span class="cMathOperator">=</span> <span class="Constant">1</span>; j <span class="cLogicalOperator">&lt;=</span> K; j<span class="cMathOperator">++</span>)
<span class="lnr">131 </span>            <span class="cFunction">scanf</span>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <span class="cBinaryOperator">&amp;</span>orders[i][j]);
<span class="lnr">132 </span>
<span class="lnr">133 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> M; i<span class="cMathOperator">++</span>)
<span class="lnr">134 </span>        <span class="Statement">for</span> (<span class="Type">int</span> j <span class="cMathOperator">=</span> <span class="Constant">1</span>; j <span class="cLogicalOperator">&lt;=</span> K; j<span class="cMathOperator">++</span>)
<span class="lnr">135 </span>            <span class="cFunction">scanf</span>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <span class="cBinaryOperator">&amp;</span>storage[i][j]);
<span class="lnr">136 </span>
<span class="lnr">137 </span>    <span class="Statement">for</span> (<span class="Type">int</span> k <span class="cMathOperator">=</span> <span class="Constant">1</span>; k <span class="cLogicalOperator">&lt;=</span> K; k<span class="cMathOperator">++</span>)
<span class="lnr">138 </span>        <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> N; i<span class="cMathOperator">++</span>)
<span class="lnr">139 </span>            <span class="Statement">for</span> (<span class="Type">int</span> j <span class="cMathOperator">=</span> <span class="Constant">1</span>; j <span class="cLogicalOperator">&lt;=</span> M; j<span class="cMathOperator">++</span>)
<span class="lnr">140 </span>                <span class="cFunction">scanf</span>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <span class="cBinaryOperator">&amp;</span>dist[k][i][j]);
<span class="lnr">141 </span>
<span class="lnr">142 </span>    <span class="Statement">return</span> <span class="Constant">true</span>;
<span class="lnr">143 </span>}
<span class="lnr">144 </span>
<span class="lnr">145 </span><span class="Type">void</span> <span class="cFunction">buildEdge</span>(<span class="Type">int</span> k)
<span class="lnr">146 </span>{
<span class="lnr">147 </span>    <span class="Comment">/*</span>
<span class="lnr">148 </span><span class="Comment">     * 0: src</span>
<span class="lnr">149 </span><span class="Comment">     * 1 to M: Storage</span>
<span class="lnr">150 </span><span class="Comment">     * M + 1 to M + N: Shopkeeper</span>
<span class="lnr">151 </span><span class="Comment">     * MAXN: dest</span>
<span class="lnr">152 </span><span class="Comment">     </span><span class="Comment">*/</span>
<span class="lnr">153 </span>
<span class="lnr">154 </span>    <span class="Type">const</span> <span class="Type">int</span>  St <span class="cMathOperator">=</span> <span class="Constant">0</span>, SK <span class="cMathOperator">=</span> M;
<span class="lnr">155 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">0</span>; i <span class="cLogicalOperator">&lt;=</span> M <span class="cMathOperator">+</span> N; i<span class="cMathOperator">++</span>) edge[i]<span class="cPointerOperator">.</span><span class="cFunction">clear</span>();
<span class="lnr">156 </span>    edge[dest]<span class="cPointerOperator">.</span><span class="cFunction">clear</span>();
<span class="lnr">157 </span>
<span class="lnr">158 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> M; i<span class="cMathOperator">++</span>) {
<span class="lnr">159 </span>        <span class="Comment">// src -&gt; St, capa = storage[i][k], cpf = 0</span>
<span class="lnr">160 </span>        <span class="Comment">// St -&gt; src, capa = 0, cpf = 0</span>
<span class="lnr">161 </span>        <span class="cFunction">addEdge</span>(src, St <span class="cMathOperator">+</span> i, storage[i][k], <span class="Constant">0</span>, <span class="Constant">0</span>);
<span class="lnr">162 </span>    }
<span class="lnr">163 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> M; i<span class="cMathOperator">++</span>)
<span class="lnr">164 </span>        <span class="Statement">for</span> (<span class="Type">int</span> j <span class="cMathOperator">=</span> <span class="Constant">1</span>; j <span class="cLogicalOperator">&lt;=</span> N; j<span class="cMathOperator">++</span>) {
<span class="lnr">165 </span>            <span class="Comment">// St -&gt; SK, capa = MAXN, cpf = dist[k][j][i]</span>
<span class="lnr">166 </span>            <span class="Comment">// SK -&gt; St, capa = 0, cpf = -dist[k][j][i]</span>
<span class="lnr">167 </span>            <span class="cFunction">addEdge</span>(St <span class="cMathOperator">+</span> i, SK <span class="cMathOperator">+</span> j, MAXN, <span class="Constant">0</span>, dist[k][j][i]);
<span class="lnr">168 </span>        }
<span class="lnr">169 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">1</span>; i <span class="cLogicalOperator">&lt;=</span> N; i<span class="cMathOperator">++</span>) {
<span class="lnr">170 </span>        <span class="Comment">// SK -&gt; dest, capa = orders[i][k], cpf = 0</span>
<span class="lnr">171 </span>        <span class="Comment">// dest -&gt; SK, capa = 0, cpf = 0</span>
<span class="lnr">172 </span>        <span class="cFunction">addEdge</span>(SK <span class="cMathOperator">+</span> i, dest, orders[i][k], <span class="Constant">0</span>, <span class="Constant">0</span>);
<span class="lnr">173 </span>    }
<span class="lnr">174 </span>}
<span class="lnr">175 </span>
<span class="lnr">176 </span><span class="Type">bool</span> <span class="cFunction">check</span>()
<span class="lnr">177 </span>{
<span class="lnr">178 </span>    <span class="Statement">for</span> (<span class="Type">int</span> i <span class="cMathOperator">=</span> <span class="Constant">0</span>; i <span class="cLogicalOperator">&lt;</span> edge[dest]<span class="cPointerOperator">.</span><span class="cFunction">size</span>(); i<span class="cMathOperator">++</span>) {
<span class="lnr">179 </span>        <span class="Type">int</span> u <span class="cMathOperator">=</span> edge[dest][i]<span class="cPointerOperator">.</span>v, j <span class="cMathOperator">=</span> edge[dest][i]<span class="cPointerOperator">.</span>p;
<span class="lnr">180 </span>        <span class="Statement">if</span> (edge[u][j]<span class="cPointerOperator">.</span>f <span class="cLogicalOperator">&lt;</span> edge[u][j]<span class="cPointerOperator">.</span>c) <span class="Statement">return</span> <span class="Constant">false</span>;
<span class="lnr">181 </span>    }
<span class="lnr">182 </span>
<span class="lnr">183 </span>    <span class="Statement">return</span> <span class="Constant">true</span>;
<span class="lnr">184 </span>}
<span class="lnr">185 </span>
<span class="lnr">186 </span><span class="Type">bool</span> <span class="cFunction">work</span>()
<span class="lnr">187 </span>{
<span class="lnr">188 </span>    <span class="Statement">if</span> (<span class="cFunction">init</span>() <span class="cLogicalOperator">==</span> <span class="Constant">false</span>) <span class="Statement">return</span> <span class="Constant">false</span>;
<span class="lnr">189 </span>
<span class="lnr">190 </span>    <span class="Type">int</span> cost <span class="cMathOperator">=</span> <span class="Constant">0</span>;
<span class="lnr">191 </span>    <span class="Statement">for</span> (<span class="Type">int</span> k <span class="cMathOperator">=</span> <span class="Constant">1</span>; k <span class="cLogicalOperator">&lt;=</span> K; k<span class="cMathOperator">++</span>) {
<span class="lnr">192 </span>        <span class="cFunction">buildEdge</span>(k);
<span class="lnr">193 </span>
<span class="lnr">194 </span>        <span class="Type">int</span> tmp <span class="cMathOperator">=</span> <span class="cFunction">mcmf</span>();
<span class="lnr">195 </span>        <span class="Statement">if</span> (<span class="cFunction">check</span>()) cost <span class="cMathOperator">+=</span> tmp;
<span class="lnr">196 </span>        <span class="Statement">else</span> {
<span class="lnr">197 </span>            <span class="cFunction">puts</span>(<span class="Constant">&quot;-1&quot;</span>);
<span class="lnr">198 </span>            <span class="Statement">return</span> <span class="Constant">true</span>;
<span class="lnr">199 </span>        }
<span class="lnr">200 </span>    }
<span class="lnr">201 </span>    <span class="cFunction">printf</span>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>, cost);
<span class="lnr">202 </span>
<span class="lnr">203 </span>    <span class="Statement">return</span> <span class="Constant">true</span>;
<span class="lnr">204 </span>}
<span class="lnr">205 </span>
<span class="lnr">206 </span><span class="Type">int</span> <span class="cFunction">main</span>()
<span class="lnr">207 </span>{
<span class="lnr">208 </span>    <span class="Statement">while</span> (<span class="cFunction">work</span>()) ;
<span class="lnr">209 </span>
<span class="lnr">210 </span>    <span class="Statement">return</span> <span class="Constant">0</span>;
<span class="lnr">211 </span>}
<span class="lnr">212 </span>
</pre>
</body>
</html>
